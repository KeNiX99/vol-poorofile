// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © kenix9961821
//@version=5
indicator('KeNiX‘s Volume Profile Auto 60-1D ', shorttitle='KNXVPA60-1D', overlay=true, max_lines_count=99, max_boxes_count=99)

i_size = 45 //input.int(25, 'parts', minval=5, maxval=50)
i_width = 1 //input(15, 'max width')
aMax = 99 //input.int(500, 'max lines', maxval=500)
c_volH = input(color.new(color.yellow, 81), title='color vol max')
c_vol = input(color.new(color.blue, 81), title='color vol')
c_POC = input(color.new(color.yellow, 9), title='color POC')

maxVol = ta.highest(volume, aMax)


chT_H = ta.change(time('1D'))
chT_Lo = ta.change(time('60'))

var t_H = 0
var t_L = 0
t_H := 1000 * 60 * 60 * 24 //periodH == '1' ? 1000 * 60 : periodH == '3' ? 1000 * 60 * 3 : periodH == '5' ? 1000 * 60 * 5 : periodH == '10' ? 1000 * 60 * 10 : periodH == '15' ? 1000 * 60 * 15 : periodH == '30' ? 1000 * 60 * 30 : periodH == '60' ? 1000 * 60 * 60 : periodH == '120' ? 1000 * 60 * 60 * 2 : periodH == '180' ? 1000 * 60 * 60 * 3 : periodH == '240' ? 1000 * 60 * 60 * 4 : periodH == '360' ? 1000 * 60 * 60 * 6 : periodH == '720' ? 1000 * 60 * 60 * 12 : periodH == '1D' ? 1000 * 60 * 60 * 24 : periodH == '3D' ? 1000 * 60 * 60 * 24 * 3 : periodH == '1W' ? 1000 * 60 * 60 * 24 * 7 : periodH == '1M' ? 1000 * 60 * 60 * 24 * 30 : 1000 * 60 * 60 * 24 * 365

t_L := 1000 * 60 * 60 //not i_auto ? periodL == '1' ? 1000 * 60 : periodL == '3' ? 1000 * 60 * 3 : periodL == '5' ? 1000 * 60 * 5 : periodL == '10' ? 1000 * 60 * 10 : periodL == '15' ? 1000 * 60 * 15 : periodL == '30' ? 1000 * 60 * 30 : periodL == '60' ? 1000 * 60 * 60 : periodL == '120' ? 1000 * 60 * 60 * 2 : periodL == '180' ? 1000 * 60 * 60 * 3 : periodL == '240' ? 1000 * 60 * 60 * 4 : periodL == '360' ? 1000 * 60 * 60 * 6 : periodL == '720' ? 1000 * 60 * 60 * 12 : periodL == '1D' ? 1000 * 60 * 60 * 24 : periodL == '3D' ? 1000 * 60 * 60 * 24 * 3 : periodL == '1W' ? 1000 * 60 * 60 * 24 * 7 : 1000 * 60 * 60 * 24 * 30 : timeframe.isseconds ? 1000 * timeframe.multiplier : timeframe.isminutes ? 1000 * 60 * timeframe.multiplier : periodL == '60' ? 1000 * 60 * 60 : periodL == '120' ? 1000 * 60 * 60 * 2 : periodL == '180' ? 1000 * 60 * 60 * 3 : periodL == '240' ? 1000 * 60 * 60 * 4 : periodL == '360' ? 1000 * 60 * 60 * 6 : periodL == '720' ? 1000 * 60 * 60 * 12 : timeframe.isdaily ? 1000 * 60 * 60 * 24 * timeframe.multiplier : timeframe.isweekly ? 1000 * 60 * 60 * 24 * 7 * timeframe.multiplier : 1000 * 60 * 60 * 24 * 30 * timeframe.multiplier

mult = t_H / t_L

var a_lines = array.new_line(i_size, na)
var a_vol = array.new_float(i_size, 0)
var a_box = array.new_box(i_size, na)
var tempArray = array.new_float(i_size, 0)
var tmpAmax = 0.
var index = 0
//var lpoc_now = na
var abox_index = 0
var alert_data_msg = ""
var line l_POC = na
line.delete(l_POC)

// if change new period  
if chT_H
    // before adding a new series of lines -> wrap up

    // Draw POC
    l_POC := line.new(line.get_x1(array.get(a_lines, index)), math.avg(line.get_y1(array.get(a_lines, index)), line.get_y1(array.get(a_lines, index + 1))), line.get_x2(array.get(a_lines, index)) + 100, math.avg(line.get_y1(array.get(a_lines, index)), line.get_y1(array.get(a_lines, index + 1))), color=c_POC)
    //lpoc_pre := math.avg(line.get_y1(array.get(a_lines, index)), line.get_y1(array.get(a_lines, index + 1)))
    // place box just 1 bar further  
    if array.size(a_box) > 0
        box.set_right(array.get(a_box, 0), bar_index)  // move latest box (right size) 1 bar_index further when new period
    // create new box
    array.unshift(a_box, box.new(bar_index, high, bar_index, low, border_color=na, bgcolor=color.new(c_vol, 95)))
    // clean-up if max is reached
    if array.size(a_box) > math.ceil(aMax / i_size)
        box.delete(array.get(a_box, array.size(a_box) - 1))
        array.pop(a_box)
    // adding a new series of lines
    for i = 0 to i_size - 1 by 1
        // create x amount of memory space for volume (lines)
        array.unshift(a_lines, line.new(bar_index, high - (high - low) / i_size * i, bar_index, high - (high - low) / i_size * (i + 1), width=1, color=c_vol))  // create new x amount of lines (parts)
        array.unshift(a_vol, 0)
        // clean-up if max is reached
        if array.size(a_lines) > aMax
            line.delete(array.get(a_lines, array.size(a_lines) - 1))
            array.pop(a_lines)
            array.pop(a_vol)

if array.size(a_lines) > 0
    //if not chT_H 
    box.set_right(array.get(a_box, 0), bar_index)  // make existing box 1 bar larger to the right
    line.set_x2(l_POC, bar_index)  // make existing POC 1 bar larger to the right
    hi = line.get_y1(array.get(a_lines, 0))  // highest high of HTF 
    lo = line.get_y2(array.get(a_lines, i_size - 1))  // lowest low of HTF 

    if high > hi
        for i = 0 to i_size - 1 by 1
            line.set_y1(array.get(a_lines, 0), high)
            hi := line.get_y1(array.get(a_lines, 0))
            line.set_y1(array.get(a_lines, i), hi - (hi - lo) / i_size * i)
            line.set_y2(array.get(a_lines, i), hi - (hi - lo) / i_size * (i + 1))
            box.set_top(array.get(a_box, 0), hi)
    if low < lo
        for i = 0 to i_size - 1 by 1
            line.set_y2(array.get(a_lines, i_size - 1), low)
            lo := line.get_y2(array.get(a_lines, i_size - 1))
            line.set_y1(array.get(a_lines, i), hi - (hi - lo) / i_size * i)
            line.set_y2(array.get(a_lines, i), hi - (hi - lo) / i_size * (i + 1))
            box.set_bottom(array.get(a_box, 0), lo)

    for i = 0 to i_size - 1 by 1
        if high >= line.get_y1(array.get(a_lines, i)) and low <= line.get_y2(array.get(a_lines, i))
            array.set(a_vol, i, array.get(a_vol, i) + volume)
            line.set_width(array.get(a_lines, i), math.round(array.get(a_vol, i)))
//lpoc_now = 0.0
if array.size(a_vol) > 0
    for i = 0 to array.size(tempArray) - 1 by 1
        line.set_color(array.get(a_lines, i), c_vol)
        array.set(tempArray, i, array.get(a_vol, i))
    tmpAmax := array.max(tempArray)
    index := array.indexof(tempArray, tmpAmax)
    line.set_color(array.get(a_lines, index), c_volH)
    l_POC := line.new(line.get_x1(array.get(a_lines, index)), math.avg(line.get_y1(array.get(a_lines, index)), line.get_y1(array.get(a_lines, index + 1))), line.get_x2(array.get(a_lines, index)) + 100, math.avg(line.get_y1(array.get(a_lines, index)), line.get_y1(array.get(a_lines, index + 1))), color=c_POC)
lpoc_now = line.get_y1(l_POC)
    
if barstate.islast
    for i = 0 to array.size(a_lines) - 1 by 1
        boxL = box.get_left(array.get(a_box, 0))
        boxR = box.get_right(array.get(a_box, 0))
        width = boxR - boxL
        line.set_width(array.get(a_lines, i), math.round(i_width / maxVol * array.get(a_vol, i)))  // at the last bar, adjust all line width's (to get a uniform comparison between lines)
        line.set_x2(l_POC, bar_index + 9)
        
        //lpoc_pre := line.get_y1(l_POC[1440])//math.avg(line.get_y1(array.get(a_lines, index+2)), line.get_y1(array.get(a_lines,  index+3)))
        //lpoc_pre := math.avg(line.get_y1(array.get(a_lines, 0)), line.get_y1(array.get(a_lines,  1)))
////=================================macd below==========
var cumVol = 0.
cumVol += nz(volume)
if barstate.islast and cumVol == 0
    runtime.error("No volume is provided by the data vendor.")
src = close
obv = ta.cum(math.sign(ta.change(src)) * volume)
fast_length = 12
slow_length = 63
signal_length = 9
fast_ma =  ta.ema(obv, fast_length)
slow_ma =  ta.ema(obv, slow_length)
macd = fast_ma - slow_ma
signal = ta.ema(macd, signal_length)
hist = macd - signal

///=============

alert_data_msg := 
          "{ \"passphrase\" : \"knxcrazywin\",\n"  
          +"\"symbol\" : \"" + syminfo.ticker + "\",\n"
          + "\"vp601Ddata\": { \n"  
          + "\"l_POC-now\": " + str.tostring(lpoc_now) + ",\n" 
          + "\"l_POC-pre\": " + str.tostring(lpoc_now[1440]) 
          + "\n},"
          + "\"MACD\": { \n"
          + "\"macd\": " + str.tostring(macd[1]) + ",\n" 
          + "\"signal\": " + str.tostring(signal[1]) + ",\n" 
          + "\"hist\": " + str.tostring(hist[1]) 
          +"\n}\n}"       
alert(message = alert_data_msg, freq = alert.freq_once_per_bar)

barcolor(color.new(color.white, 9))  // make candles transparent


